package main

import (
	"fmt"
	"math/rand"
	"time"

	"github.com/DzananGanic/numericalgo/interpolate"
	"github.com/DzananGanic/numericalgo/interpolate/linear"
)

func main() {

	totalDesiredPower := 150000.0 // Required wind speed (kW)

	// Wind speed array
	turbX := []float64{0, 3, 3.2, 3.4, 3.6, 3.8, 4, 4.2, 4.4, 4.6, 4.8, 5, 5.2, 5.4, 5.6,
		5.8, 6, 6.2, 6.4, 6.6, 6.8, 7, 7.2, 7.4, 7.6, 7.8, 8, 8.2, 8.4, 8.6, 8.8, 9,
		9.2, 9.4, 9.6, 9.8, 10, 10.2, 10.4, 10.6, 10.8, 11, 11.2, 11.4, 11.6, 11.8}

	// turbX = []float64{0, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600,
	// 	5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000,
	// 	9200, 9400, 9600, 9800, 10000, 10200, 10400, 10600, 10800, 11000, 11200, 11400, 11600, 11800}

	// Output power for the determined wind speed
	turbY := []float64{0, 20.88167528, 34.80278896, 55.68445948, 90.48724368,
		125.2900279, 167.0533689, 208.81671, 257.5406078, 313.2250626, 375.8700741,
		438.5150857, 508.1206541, 577.7262225, 654.2923477, 737.8190298, 821.3457119,
		911.8329508, 1002.32019, 1106.728542, 1211.136895, 1322.505804, 1461.716941,
		1580.046407, 1712.296987, 1851.508124, 1990.719261, 2122.969841, 2262.180978,
		2373.549887, 2477.95824, 2575.406036, 2631.09049, 2700.696059, 2735.498843,
		2763.34107, 2777.262184, 2777.262184, 2777.262184, 2777.262184, 2777.262184,
		2777.262184, 2777.262184, 2777.262184, 2777.262184, 2777.262184}

	// Approximated Power Curve
	windCurve := linear.New()
	windCurve.Fit(turbX, turbY)

	// Wind values for wach month
	windSpeed := map[string]float64{
		"Jan": 5.5,
		"Feb": 6.5,
		"Mar": 6.5,
		"Apr": 6.5,
		"May": 6.5,
		"Jun": 6.8,
		"Jul": 7.5,
		"Aug": 6.0,
		"Sep": 5.5,
		"Oct": 3.5,
		"Nov": 4.5,
		"Dic": 5.5,
	}

	// The random function is initialized
	rand.Seed(time.Now().UnixNano())
	numTrials := 1
	marginOfError := 3.0

	// The value of the wind for a determinated moment is obtained based on the wind speed for each month
	windVal := int(SimulateWindAverage(windSpeed, numTrials, marginOfError) * 100)
	fmt.Println("wind: ", float64(windVal)/100)

	// The corresponding power from a single turbine is obtained from the interpolation of the Power Curve
	inter, err := interpolate.WithSingle(windCurve, float64(windVal)/100)

	// The number of required turbines is obtained according to the desired Power and the power just obtained
	initialTurbines := int(totalDesiredPower / inter)
	fmt.Println("The average wind speed is: ", windVal)
	fmt.Println("The power per turbine is: ", inter, err)
	fmt.Println("The number of turbines is: ", initialTurbines)

	totalAvgPower := 0.0
	powerPerMinute := 0.0

	// The average generated power is obtained by calculating the value for 60 iterations corresponding to 60 minutes
	for i := 0; i < 60; i++ {
		powerPerMinute = 0.0

		// For each minute, it is calculated the total generated power
		for j := 0; j < initialTurbines; j++ {

			// The wind speed for a determinated turbine is obtained based on the wind speed for each month
			windxx := int(SimulateWindAverage(windSpeed, numTrials, marginOfError))

			// The corresponding power from a single turbine is obtained from the interpolation of the Power Curve
			inter, err = interpolate.WithSingle(windCurve, float64(windxx))

			// The power generated by the turbine is added
			powerPerMinute += inter
			// fmt.Println("this", windxx)
			// fmt.Println("Power", powerPerMinute)
		}

		// The power generated through one minute is added
		totalAvgPower += powerPerMinute
		fmt.Println("In a minute power", powerPerMinute)
	}

	// The average power is calculated
	totalAvgPower = totalAvgPower / 60
	fmt.Println("Total avg power: ", totalAvgPower/1000, " MW")
}

//SimulateWindAverage s
func SimulateWindAverage(values map[string]float64, numSimulations int, marginOfError float64) float64 {
	windAvrg := 0.0

	//simulate wind values for several years
	for i := 0; i < numSimulations; i++ {
		windAvrg += SimulateOneYear(values, marginOfError)
	}

	return windAvrg / float64(numSimulations)
}

// SimulateOneYear hh
func SimulateOneYear(values map[string]float64, marginOfError float64) float64 {
	windAvrgYear := 0.0

	for month := range values {
		windSpeed := values[month]
		adjustedWindSpeed := AddNoise(windSpeed, marginOfError)
		windAvrgYear += (adjustedWindSpeed / 12)
	}
	return windAvrgYear
}

// AddNoise ss
func AddNoise(windSpeed float64, marginOfError float64) float64 {
	x := rand.NormFloat64()
	x = x / 2
	x = x * marginOfError
	return x + windSpeed
}
